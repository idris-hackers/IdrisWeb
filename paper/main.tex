%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{silence}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\WarningsOff

\begin{document}
\newcommand{\idris}{\textsc{Idris}}
\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{Draft for submission to IFL 2013}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Correct and Secure Web Programming using Dependent Types and Embedded Domain-Specific Languages}
%\subtitle{Using Embedded Domain-Specific Languages to Improve Confidence in Web Applications}

\authorinfo{Simon Fowler \and Edwin Brady}
           {School of Computer Science \\ University of St Andrews \\ St Andrews \\ Scotland}
           {Email: \{sf37, ecb10\}@st-andrews.ac.uk}

\maketitle

\begin{abstract}
Dependently-typed languages allow types to be used to impose arbitrarily-specific constraints on programs, in turn allowing for easier reasoning about the operation of such programs. Stronger specifications do however bring with them the disadvantage that it becomes increasingly difficult to write programs that are accepted by the type checker, and additional proofs may have to be specified by a user.

Research into embedded domain-specific languages attempt to address this problem by introducing a layer of abstraction over the underlying types, allowing for domain-specific code to be written in high-level languages which use dependent types to enforce certain invariants without requiring complex proofs to be specified.

In this paper, we apply this technique to web programming, showing that embedded domain-specific languages can be constructed to enforce resource usage protocols associated with common web operations such as CGI, database access and session handling. Additionally, we show that this technique may be employed to allow the creation and handling of web forms which retain type information, reducing the scope for programmer error and attacks which exploit the loss of type information, such as SQL injection.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%term1, term2

%\keywords
%keyword1, keyword2

\section{Introduction}
Web applications, whilst ubiquitous, are also prone to incorrect construction and security exploits. The majority of web applications are written in dynamically-checked scripting languages \cite{}, which allow rapid development but at the same time do not give the same static guarantees about runtime behaviour afforded by programs with more expressive, static type systems, instead relying on extensive unit testing to ensure correctness and security. 

An alternative approach is to ensure that a program is semantically sound before it is run. Through the use of \textit{dependent types}, it is possible to impose arbitrarily strong specifications on programs, requiring that these specifications are fulfilled before a program successfully type-checks. A large drawback of this, however, is that automatic verification by the compiler is often impossible, requiring additional proofs to be specified by the developer. This severely limits the uptake of dependently-typed languages.

This complexity can be ameliorated through the use of \textit{embedded domain-specific languages} (EDSLs), which aim to abstract away from the complexity of the underlying dependent type mechanisms, allowing users to write verfied domain-specific code without having to consider the underlying verification mechanisms.   %TODO: rephrase this

% Probably could do with rewriting a lot of this
Web applications are also intrinsically side-effecting, requiring extensive network communication, database queries and file I/O. Purely functional programming languages such as Haskell \cite{haskell} handle this monadically, but the composition of different effects can be difficult. Developers either make use of \textit{monad transformers} to compose different effects, or handle everything in a much coarser-grained monad.

\idris{} \cite{brady2011idris} is a language with full dependent types, and extensive support for embedded domain-specific languages through ad-hoc syntax overloading and syntax macros. Through the use of \idris{}, and the \texttt{Effects} library \cite{brady:effects}, we present a dependently-typed web framework, which allows for the construction of programs with additional guarantees about correctness and security, whilst minimising the increase in development complexity. 



\subsection{Contributions}
The primary contribution of this paper is the application of previous work to show that dependent types may be used to provide stronger static guarantees about the correctness and security of web applications, whilst minimising additional overhead. In particular:

\begin{itemize}
\item Representations of CGI, SQLite and a simple session handler as \textit{algebraic effects}, allowing programs to be accepted only when they adhere to specific resource usage protocols.
\item A form-handling mechanism, which preserves type information and therefore increases applications' resilience to attacks such as SQL injection.
\item A message board application making use of the framework, and showing that the framework may be used for practical applications.
\end{itemize}

All code used in this paper is available online at \\ \verb+http://www.github.com/SimonJF/IdrisWeb+.
% =================================================
% =================================================

\section{An overview of the \texttt{Effects} library}
\texttt{Effects} \cite{effects} is an EDSL which handles side-effects such as database access as \textit{algebraic effects}, allowing for greater code modularity. This section is intended to serve as a brief introduction to the library; for more information, see \cite{brady:effects}.

An effect is represented as an instance of the \texttt{EFFECT} type. Such instances may be associated with a \textit{resource}, 
Describing a program in the \texttt{Effects} library is achieved using the following data type:
{\small
\begin{verbatim}
EffM : (m : Type -> Type) ->
       (es : List EFFECT) ->
       (es’ : List EFFECT) ->
       (a : Type) -> Type
\end{verbatim}
}
\texttt{EffM} is a type that is parameterised over an execution context (\texttt{m}), a list of effects that the program may use (\texttt{xs}), a list of effects at the end of the program's execution (\texttt{es'}), and a return type (\texttt{a}). The list of input types can be used to ensure that an operation may only be called when the program is in a particular state, and since the list of input effects may differ from the list of output effects, we may modify the resource associated with the state after each operation. This allows us to simply enforce a resource usage protocol, and deviation from this protocol will result in a compile-time error.

Implementing a new effect involves creating a new algebraic data type, of kind \texttt{Effect}, which describes the available operations and how they modify the resource associated with the effect. Each operation consists of an initial resource \texttt{res}, the resource at the end of the operation \texttt{res'}, and the output type of the operation \texttt{t}.
{\small
%TODO: Execution
\begin{verbatim}
Effect : Type
Effect = (res : Type) -> (res’ : Type) ->
         (t : Type) -> Type
\end{verbatim}
}
Operations are made available to users by writing functions with the correct \texttt{EffM} type, which may then be used to invoke the operation from within an effectful program.
{\small
\begin{verbatim}
queryPostVar : 
 String -> 
 Eff m [CGI (InitialisedCGI TaskRunning)] 
   (Maybe String)
queryPostVar query = (QueryPostVar query)
\end{verbatim}
}
Additionally, we define \textit{handlers}, which describe how each operation is interpreted in a given execution context. Finally, \texttt{Effect} instances are promoted to \texttt{EFFECT} instances through the use of the \texttt{MkEff} constructor, which is provided with the initial resource value.

% =================================================
% =================================================

\section{Modelling resource usage protocols}
In this section, we show how three such effects; CGI, SQLite and a simple session handler, may be implemented, and describe the benefits of developing programs using this technique over simply handling them in the IO context or as part of a monad transformer.

% =================================================

\subsection{CGI}
%TODO: Fix up the labels
\begin{figure}[htpb!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}[>=latex]
  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=6em, font={\sffamily\bfseries}]
  
  \tikzstyle{stateEdgePortion} = [black,thick];
  \tikzstyle{stateEdge} = [stateEdgePortion,->];
  \tikzstyle{edgeLabel} = [pos=0.5, font={\sffamily\small}];

  \node[initial,state] (A)              {Uninitialised};
  \node[state]         (B) [below of=A] {Initialised};
  \node[state]         (C) [below of=B] {TaskRunning};
  \node[state]         (D) [below of=C] {TaskCompleted};
  \node[state]         (E) [below of=D] {HeadersWritten};
  \node[state]         (F) [below of=E] {ContentWritten};

  \path (A) edge[stateEdge]   node[edgeLabel, xshift=3em] {\texttt{initialise}} (B)
        (B) edge[stateEdge]   node[edgeLabel, xshift=3em] {\texttt{startTask}} (C)
        (C) edge[stateEdge]   node[edgeLabel, xshift=3em] {\texttt{finishTask}} (D)
        (D) edge[stateEdge]   node[edgeLabel, xshift=3.5em] {\texttt{writeHeaders}} (E)
        (E) edge[stateEdge]   node[edgeLabel, xshift=3.5em] {\texttt{writeContent}} (F);
\end{tikzpicture}
}
\caption{CGI States}
\label{fig:cgistates}
\end{figure}

CGI is used to invoke an application on a web server, making use of environment variables to convey information gained from an HTTP request and using standard output to communicate with the remote client. Importantly, HTTP headers must be correctly written to the user prior to any other output; failure to do so will result in an internal server error.

A previous implementation of CGI in \idris{} implemented CGI as an extension of monadic IO. Whilst basic functionality worked correctly, this approach had several disadvantages; most notably, it was possible to perform arbitrary IO at any point in the program. If this were to happen, then the program would fail due to the fact that headers had not been written to the client.

By modelling CGI as an algebraic effect, we may enforce a resource usage protocol which, even though the program may be running in an IO execution context, prevents arbitrary IO from being performed and therefore ensures that the headers are firstly written correctly. In order to accomplish this, we define an effect, \texttt{Cgi}, and an associated resource, \texttt{InitialisedCGI}, which is parameterised over the current state, \texttt{CGIStep}. This resource describes the current state, alongside a \texttt{CGIInfo} record which contains information from the request. We represent an uninitialised CGI effect as the unit type, ().
{\small
\begin{verbatim}
data CGIStep = Initialised 
             | TaskRunning 
             | TaskCompleted 
             | HeadersWritten 
             | ContentWritten

data InitialisedCGI : CGIStep -> Type where
  ICgi : CGIInfo -> InitialisedCGI s
\end{verbatim}
}
Figure ~\ref{fig:cgistates} shows the states through which the CGI program progresses. Each operation performed in an effectful program requires the resource to be of a certain type, and the completion of the operation may alter the resource.

Upon creation, the CGI application is uninitialised, meaning that the environment variables and request have not been retrieved. The only operation that can be performed in this state is initialisation: by calling \texttt{initalise}, a CGIInfo record is populated, and the state transitions to \texttt{Initialised}. The \texttt{Init} operation is defined as part of the \texttt{Cgi} algebraic data type, and involves transitioning from the uninitialised state to the initialised state.

{\small
\begin{verbatim}
data Cgi : Effect where
    Init : Cgi () (InitialisedCGI Initialised) ()
    StartRun : Cgi (InitialisedCGI Initialised) 
                   (InitialisedCGI TaskRunning) ()
    FinishRun : Cgi (InitialisedCGI TaskRunning) 
                    (InitialisedCGI TaskCompleted) ()
    WriteHeaders : Cgi (InitialisedCGI TaskCompleted) 
                       (InitialisedCGI HeadersWritten) ()
    WriteContent : Cgi (InitialisedCGI HeadersWritten) 
                       (InitialisedCGI ContentWritten) ()
    OutputData : String -> 
                 Cgi (InitialisedCGI TaskRunning) 
                     (InitialisedCGI TaskRunning) ()
    RunAction : Env IO (CGI (InitialisedCGI TaskRunning) 
                               :: effs) -> 
                       CGIProg effs a -> 
                       Cgi (InitialisedCGI TaskRunning) 
                           (InitialisedCGI TaskRunning) a
    ...
    
\end{verbatim}
}
User code executes in the \texttt{TaskRunning} state. Several operations, such as querying the POST and GET variables, are available in this state, alongside functions to output data to the web page and append data to the response headers. It is important to note, however, that at this stage nothing is written to the page, with the \texttt{output} and \texttt{addHeader} functions instead modifying the CGIInfo record so that it can be printed at the end of the program's execution, in turn ensuring that the headers are first written.

After the user code has finished execution, control returns to the library code. At this point, the state transitions to TaskCompleted, the headers are written, and the headers are output to the request. Finally, after the headers have been written, the content is then written, which completes the process. Since we parameterise the resource over a state, we may ensure that certain operations only happen in a particular prescribed order.

In order to make use of the CGI framework, users specify a function of the following type:
{\small
\begin{verbatim}
CGIProg : List EFFECT -> Type -> Type
CGIProg effs a = 
 Eff IO (CGI (InitialisedCGI TaskRunning) :: effs) a
\end{verbatim}
}
This is then passed, along with initial values for other effects that the user may wish to use, to the runAction function, which invokes the RunAction operation and executes the user-specified action.

% =================================================

\subsection{SQLite}

%TODO: Fix up the labels
\begin{figure}[htpb!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}[>=latex]
  \tikzset{every loop/.style={min distance=10mm,looseness=5}}
  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=6em, font={\sffamily\bfseries}]
  
  \tikzstyle{stateEdgePortion} = [black,thick];
  \tikzstyle{stateEdge} = [stateEdgePortion,->];
  \tikzstyle{edgeLabel} = [pos=0.5, font={\sffamily\small}];

  \node[initial,state] (A)              {Uninitialised};
  \node[state]         (B) [below of=A] {ConnectionOpened};
  \node[state]         (C) [below of=B] {PreparedStatementOpen};
  \node[state]         (D) [below of=C] {PreparedStatementBinding};
  \node[state]         (E) [below of=D] {PreparedStatementBound};
  \node[state]         (F) [below of=E] {PreparedStatementExecuting};

  \path (A) edge[stateEdge]   node[edgeLabel, xshift=3em] {\texttt{openDB}} (B)
        (B) edge[stateEdge, bend right=80]   node[edgeLabel, xshift=3em] {\texttt{closeDB}} (A)
        (B) edge[stateEdge, bend left=80]   node[edgeLabel, xshift=3em] {\texttt{connFail}} (A)
        (B) edge[stateEdge]   node[edgeLabel, xshift=4em] {\texttt{prepareStatement}} (C)
        (C) edge[stateEdge, bend left=85]   node[edgeLabel, xshift=-3.5em] {\texttt{stmtFail}} (A)
        (C) edge[stateEdge]   node[edgeLabel, xshift=3em] {\texttt{startBind}} (D)
        (D) edge[stateEdge]   node[edgeLabel, xshift=3.5em] {\texttt{finishBind}} (E)
        (E) edge[stateEdge, bend left=85]   node[edgeLabel, xshift=-3.5em] {\texttt{bindFail}} (A)
        (E) edge[stateEdge]   node[edgeLabel, xshift=3.5em] {\texttt{beginExecution}} (F)
        (F) edge[stateEdge, bend right=85]   node[edgeLabel, xshift=3.5em] {\texttt{finalise}} (B)
        (F) edge[stateEdge, bend right=85]   node[edgeLabel, xshift=3.5em] {\texttt{executeFail}} (A)
            edge[stateEdge, loop left]   node[edgeLabel, text width=2cm, xshift=2em] {\texttt{nextRow, reset}} (B);
\end{tikzpicture}
}
\caption{SQLite Resource Usage Protocol}
\label{fig:sqlitestates}
\end{figure}


SQLite is a lightweight SQL database engine \cite{sqlite} (TODO: More introduction-y stuff). We make use of SQLite due to its simplicity, although we envisage that these concepts would be applicable to more complex database management systems. Access to the SQLite library is provided through the use of the \idris{} foreign function interface \cite{brady2011idris}, which is beyond the scope of this paper.

The creation, preparation and execution of SQL queries has a very specific usage protocol, with several possible points of failure. Failure is handled in traditional web applications by the generation of exceptions, which may be handled in the program.
Handling such exceptions is often optional, however, and in some cases unhandled errors may cause a deployed web application to display an error to the user. Such errors can be used to determine the structure of an insecure SQL query, and are often used by attackers to determine attack vectors for SQL injection attacks.

Figure ~\ref{fig:sqlitestates} shows the resource usage protocol for the SQLite library. There are three main phases involved in the usage of the SQLite effect: connection to the database, preparation of a query, and execution of the query. This is reflected in the resource associated with the SQLite effect, which again is parameterised by the current state.
{\small
\begin{verbatim}
data SQLiteRes : Step -> Type where
  OpenConn : DBPointer -> SQLiteRes s
  OpenStmt : DBPointer -> StmtPointer -> SQLiteRes s
  ExecutingStmt : DBPointer -> 
                  StmtPointer -> 
                  StepResult -> 
                  SQLiteRes s
                  
data DBPointer = ValidConn Ptr
               | InvalidConn

data StmtPointer = ValidStmt Ptr
                 | InvalidStmt 
\end{verbatim}
}
If a failure happens at any point during the computation, the resource is updated to reflect the failure. At this point, no further side-effecting requests are made to the underlying SQLite library, in order to ensure safety. The \texttt{connFail}, \texttt{stmtFail}, \texttt{bindFail} and \texttt{executeFail} utility functions allow for failures, once detected, to be handled by executing the appropriate sequence of state transition functions to dispose of any open resources and return to the initial state. 

%Queries are evaluated through one or more calls to the \texttt{nextRow} function, which either executes an update statement or returns the next row of a result set. 
SQL queries are evaluated in SQLite upon a call to the library function \texttt{sqlite3\_step()}. In the case that a statement returns a result set, each subsequent call retrieves another row for processing using a column access function. Once all rows have been retrieved, the library returns \texttt{SQLITE\_DONE}, meaning that no further calls should be made without resetting the function. We encapsulate this requirement through the \texttt{StepResult} data type within the \texttt{ExecutingStmt} constructor. 
{\small
\begin{verbatim}
data StepResult = Unstarted
                | StepFail
                | StepComplete
                | NoMoreRows
\end{verbatim}
}
Each call to \texttt{nextRow}, which is a wrapper around the underlying \texttt{sqlite3\_step()} function, returns a result of type \texttt{StepResult}, which is then reflected in the resource. Calls to \texttt{sqlite3\_step()} are only executed if the previous \texttt{StepResult} is either \texttt{Unstarted} or \texttt{StepComplete}. We may therefore statically guarantee that only calls that will return a valid result are executed. 

By incorporating pointers to open connections and prepared statements into the resource associated with the effect, we introduce a further layer of abstraction, hiding implementation details from the developer and encouraging cleaner and less error-prone code. 

\subsubsection{Example Code}
Programs making use of the DSL should look familiar to developers even without a background in functional programming. To demonstrate the functionality of the library, we present a simple example wherein a database is queried in order to enumerate the contents of a simple table. Due to the fact that the \texttt{Effects} library overloads the bind operator, we may make use of \texttt{do}-notation, facilitating the usage of an imperative style.

Firstly, we define a function of type:
{\small
\begin{verbatim}
Eff IO [SQLITE ()] (Either String (List (String, Int)))
\end{verbatim}
}
This means that the program will be run in the IO execution context, and must start and end with no active resources. The return type indicates that either a list of \text{(String, Int)} pairs, representing names and ages in the database, or an error will be returned. 
{\small
\begin{verbatim}
testSelect : Eff IO [SQLITE ()] 
             (Either String (List (String, Int)))
testSelect = do
  open_db <- openDB "people.db"
  if open_db then do
    let sql = "SELECT * FROM `test`;"
    sql_prep_res <- prepareStatement sql
    if sql_prep_res then do 
      startBind
      finishBind
      beginExecution
      results <- collectResults
      finaliseStatement
      closeDB
      return $ Right results
    else do err <- stmtFail
            return $ Left err
  else do err <- connFail
          return $ Left err $
\end{verbatim}
}
The program firstly attempts to open a connection to the ``people.db'' database. At this point, since the \texttt{OpenDB} operation has been invoked, the program transitions to the \texttt{ConnectionOpened} state. The \texttt{openDB} function returns a Boolean value indicating whether or not the operation is successful. If not, then the \texttt{connFail} function is called to generate an appropriate error and dispose of the resources.

A call to \texttt{prepareStatement} attempts to create a prepared statement, and a subsequent call to \texttt{beginExecution} allows data to be retrieved from the database.

\texttt{CollectResults} is a simple function which makes a call to \texttt{nextRow} in order to make the next row of the result set available for processing, and uses the \texttt{getColumnText} and \texttt{getColumnInt} functions to retrieve the data from the database. This function is then recursively called until there are no more rows to process.
{\small
\begin{verbatim}
collectResults : 
  Eff IO 
  [SQLITE (SQLiteRes PreparedStatementExecuting)] 
  (List (String, Int))
collectResults = do
  step_result <- nextRow
  case step_result of
      StepComplete => do name <- getColumnText 1
                         age <- getColumnInt 2
                         xs <- collectResults
                         return $ (name, age) :: xs
      NoMoreRows => return []
      StepFail => return [] $
\end{verbatim}
}

In order to decrease unnecessary boilerplate code in user applications, we provide functions which abstract out unnecessary parts of this process. In order to do this, we define the algebraic data type \texttt{DBVal}, which is a tagged union over simple primitive types:
{\small
\begin{verbatim}
data DBVal = DBInt Int
           | DBText String
           | DBFloat Float
           | DBNull
\end{verbatim}
}
We also make use of the \texttt{ResultSet} type, which is a list of returned database rows.
\begin{verbatim}
ResultSet : Type
ResultSet = List (List DBVal)
\end{verbatim}
Using these, we may implement a function, \texttt{ExecuteSelect}, which, given a query, a list of variables to bind and their associated indices within the query, and a function which is used to extract information out of each returned database row, returns either a \texttt{ResultSet} or an error.
{\small
\begin{verbatim}
executeSelect : String ->
                String -> 
                List (Int, DBVal) -> 
                (Eff m [SQLITE 
                  (SQLiteRes PreparedStatementExecuting)
                   ] 
                 (List DBVal)
                ) -> 
                Eff m [SQLITE ()] (Either String ResultSet)
\end{verbatim}
}
% =================================================

\subsection{A Simple Session Handler}
All but the most trivial web applications require some persistent state across separate requests. This is often done through an abstraction of a \textit{session}, wherein a cookie is set on the remote host containing a unique session ID, which is in turn used to retrieve data. In this section, we describe the implementation of a simple session handler, and the resource usage protocol involved. 

A major strength of the \texttt{Effects} library is that it allows for simple composition of individual, fine-grained effects. By combining the individual CGI and SQLite components, we may construct a simple session handler to provide a notion of state across separate web requests. 

We implement this by having a SQLite database, containing two tables: \texttt{session}, which stores session keys and their associated expiry dates, and \texttt{sessiondata}, which contains the data associated with each session. A datum associated with the session is described as a tagged union containing one of the primitive types \texttt{String}, \texttt{Bool} or \texttt{Int}, which is serialised alongside a type tag for storage in the database.

%TODO: Fix up the labels
\begin{figure}[htpb!]
\centering
\scalebox{0.8}{
\begin{tikzpicture}[>=latex]
  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=7.5em, font={\sffamily\bfseries}]
  
  \tikzstyle{stateEdgePortion} = [black,thick];
  \tikzstyle{stateEdge} = [stateEdgePortion,->];
  \tikzstyle{edgeLabel} = [pos=0.5, font={\sffamily\small}];

  \node[initial,state] (A)              {SessionUninitialised};
  \node[state]         (B) [below of=A] {SessionInitialised};

  \path (A) edge[stateEdge]   node[edgeLabel, xshift=-1cm, text width=3cm] {\texttt{loadSession, createSession}} (B)
        (B) edge[stateEdge, bend right=80]   node[edgeLabel, xshift=6em, text width=3cm] {\texttt{writeToDB, discardSessionChanges, deleteSession}} (A)
            edge[stateEdge, loop left]   node[edgeLabel] {\texttt{updateSession}} (B);
\end{tikzpicture}
}
\caption{Session Handler Resource Usage Protocol}
\label{fig:sessionstates}
\end{figure}

Figure ~\ref{fig:sessionstates} shows the resource usage protocol associated with the session handler. In this application, there exist two states: \texttt{SessionUninitialised}, in which the user may load or create a new session, and \texttt{SessionInitialised}, in which the user may update the representation of the session in memory, serialise the session and write it to the database, or delete the session and invalidate the user's session key. The introduction of these two states ensures that changes are explicitly either written or discarded, eliminating the possibility of a developer updating the session but neglecting to commit it to persistent storage.

Much akin to the SQLite effect, we encapsulate failure by reflecting it in the resource associated with the effect. 
{\small
\begin{verbatim}
data SessionStep = SessionUninitialised
                 | SessionInitialised

data SessionRes : SessionStep -> Type where
  InvalidSession : SessionRes s  
  ValidSession   : SessionID -> 
                   SessionData -> 
                   SessionRes s
\end{verbatim}
}
The \texttt{SessionRes} data type is parameterised over the current state, which determines which operations may be performed, and has two constructors: \texttt{InvalidSession} and \texttt{ValidSession}. If an operation such as creating a new session fails, no further side-effecting calls will be made, in turn preserving integrity. 

% =================================================

\section{Type-aware form handling}
Programming web applications often involves processing user data, which may then be used in further effectuful computations. Data submitted using a form is transmitted over the internet as a string as part of an HTTP request, which traditionally involves losing associated type information. 

This can in turn increase lead to risks; developers may assume that a data is of a certain type, and therefore discount the possibility that it may have been modified by an attacker. One example would be the traversal of paginated data, in which a form is used to make a request to retrieve the next page of data. This may involve sending an integer detailing the current page, which could be used in a query such as:

{\small
\begin{verbatim}
SELECT `name`, `age` FROM `staff` LIMIT ' + page + ', 5
\end{verbatim}
}
The \texttt{page} variable is assumed to be an integer, but may instead be modified by an attacker to include a malicious string which would alter the semantics of the query, allowing an attacker to execute a blind SQL injection attack. % Might be a good idea to cite an SQL injection paper which uses LIMIT clauses here

In this section, we present a mechanism by which we introduce a web form DSL for the creation of forms which preserve type information. Once the form has been submitted, retrieved information is passed directly to a developer-specified function for handling, without the need to manually check and deserialise data. 

\subsection{Form Construction}
Each form element is specified to hold a particular type of data, which is then passed directly as that particular type, assuming that the correct type of data is specified by the user, to the handler function. In order to encapsulate this, we firstly define the allowed data types as part of an algebraic data type, \texttt{FormTy}.
{\small
\begin{verbatim}
data FormTy = FormString
            | FormInt
            | FormBool
            | FormFloat
            | FormList FormTy 
\end{verbatim}
}
In \idris{}, types are first-class, meaning that they may be treated like other terms in computations. We use this to convert between abstract and concrete representations of allowed form types:
{\small
\begin{verbatim}
interpFormTy : FormTy -> Type
interpFormTy FormString = String
interpFormTy FormInt = Int
interpFormTy FormBool = Bool
interpFormTy FormFloat = Float
interpFormTy (FormList a) = List (interpFormTy a)
\end{verbatim}
}
%
In order to specify a form, we once again make use of the \texttt{Effects} library in order to create a resource-aware EDSL. By recording the type of each form element as it is added in the type of the form, we may statically ensure that the user-supplied handler function is of the correct type to handle the data supplied by the form. If a handler function with with different types is supplied, then this will result in a compile-time type error.

\idris{} allows for implicit arguments to be bound across a block of code through \texttt{using} notation. We may therefore parameterise the EDSL over the types associated with each form element, and the effects required by the handler function.

{\small
\begin{verbatim}
using (G : Vect FormTy n)
 data FormRes : Vect FormTy n -> Type where
   FR : Nat -> Vect FormTy n -> String -> FormRes G

 data Form : Effect where
   AddTextBox : (label : String) -> 
                (fty : FormTy) -> 
                (Maybe (interpFormTy fty)) -> 
                Form (FormRes G) (FormRes (fty :: G)) () 
   ...
   Submit : interpCheckedFnTy G effs t -> 
            String -> 
            (effs : List WebEffect) -> 
            (t : FormTy) -> 
            Form (FormRes G) (FormRes []) String
\end{verbatim}
}
The implementation of the form EDSL also contains other constructs for additional form elements such as radio buttons and check boxes, but these are omitted here for brevity.

The resource associated with the EDSL, \texttt{FormRes}, is parameterised over a vector of the types associated with each element. The constructor, \texttt{FR}, requires the number of elements in the form in order to allow for the naming of new elements, the vector of element types, and the currently generated HTML for the form. It is necessary to keep track of the element types at both the type and value level as we must use the values in later computations when serialising the handler function. 

By adding elements to the form, the vector of form types \texttt{G} is updated, as seen in the output value of \texttt{AddTextBox}. Additionally, HTML for the form element is generated, and stored in the resource, which is returned by the \texttt{addSubmit} function in order for it to be displayed on the web page.

To specify a form instance, we define a function of type \texttt{UserForm}:
{\small
\begin{verbatim}
UserForm : Type
UserForm = EffM m [FORM (FormRes []) 
                        (FormRes [])] String
\end{verbatim}}
All forms are required to include a submit button, as mandated by the requirement that the input and output resource contains an empty list of types; this requirement is fulfilled as per the output resource type of the \texttt{AddSubmit} operation. As the creation of a form is a pure function which does not include side effects, we do not restrict the handler to IO as with previously-discussed EDSLs, instead denoting the fact that it may be run in any handler with the implicit variable \texttt{m}.

Handlers may only be associated with a form if they have argument types corresponding to the types associated with the form elements. Additionally, we wish to name the function in order for it to be serialised, whilst requiring a proof that the specified name is associated with the function. If this were not the case, it would be possible to specify a function which satisfies the type requirement, without guaranteeing that it the serialised data corresponded to that function, thus rendering the check pointless. 

Before associating a handler function with the form, we must firstly specify the effects available to the handler. This is done through the use of the \texttt{useEffects}, which updates the list of effects in the type of the form resource. By doing this, we may subsequently use the effects in calculations at the type level, in particular when calculating the type of the handler function for the form. 
{\small
\begin{verbatim}
useEffects : (effs : List WebEffect) ->
             EffM m [FORM (FormRes G E)] 
                    [FORM (FormRes G effs)] ()
useEffects effs = (UseEffects effs)
\end{verbatim}}
Whilst it is not possible to serialise arbitrary effects due to the associated difficulties with serialising initial resource environments, we allow for three effects to be serialised: \texttt{CGI}, \texttt{SQLITE} and \texttt{SESSION}. This is, however, not an inherent limitation as the \texttt{Effects} library allows for the introduction of effects within an effectful computation.
%
We may specify a handler function of type \texttt{FormHandler}:
\begin{verbatim}
FormHandler : List EFFECT -> Type
FormHandler effs = Eff IO effs ()
\end{verbatim}
In order to associate a handler with a form, we may call the \texttt{addSubmit} function:
%
\begin{verbatim}
  addSubmit : (f :  mkHandlerFn ((reverse G), E)) ->
              (fns : HandlerList) ->
              {default tactics { applyTactic 
                findFn 100; solve; }
               prf : FnElem f fns} ->
              EffM m [FORM (FormRes G E)]
                     [FORM (FormRes [] [])] 
                     String
  addSubmit f handlers {prf} = (Submit f name)
    where name : String
          name = getString' f handlers prf          
\end{verbatim}
%
Let us look at each aspect of this function in turn. Firstly, the \texttt{mkHandlerFn} function calculates the required type of the handler function from the list of types associated with the form elements, and the effects we specified with the \texttt{useEffects} function. Note that since we prepend types to the list of \texttt{FormTy}s as opposed to prepending them, we must reverse the list.
{\small
\begin{verbatim}
MkHandlerFnTy : Type
MkHandlerFnTy = (List FormTy, List WebEffect)

mkHandlerFn' : List FormTy -> List WebEffect -> Type
mkHandlerFn' [] effs = FormHandler (interpWebEffects effs) 
mkHandlerFn' (x :: xs) effs = Maybe (interpFormTy x) -> 
                              mkHandlerFn' xs effs 

mkHandlerFn : MkHandlerFnTy -> Type 
mkHandlerFn (tys, effs) = mkHandlerFn' tys effs 
\end{verbatim}
}
The \texttt{mkHandlerFn} function takes as its argument a tuple describing the arguments and web effects available to the function. When constructing the function type, we encase all arguments withing \texttt{Maybe} type, in order to handle failure should the supplied data fail to parse to the specified type. We may then extract the information through pattern matching.

To store a reference to a handler function, we use the \texttt{HandlerFn} type:
\begin{verbatim}
public
HandlerFn : Type
HandlerFn = (ft ** (mkHandlerFn ft, String))
\end{verbatim}
%
The \texttt{**} notation denotes a dependent pair, wherein one argument, in this case the concrete handler function, depends on another, namely \texttt{MkHandlerFnTy} data used to construct the type of the handler function. We also store a unique string identifier, which is used to serialise a reference to the handler function. We then store each \texttt{HandlerFn} in a \texttt{HandlerList}.

\begin{verbatim}
public
HandlerList : Type
HandlerList = List HandlerFn
\end{verbatim}
To enforce the requirement that a supplied handler function must reside in the list of available handlers, and therefore allow us to retrieve the name with which to serialise the handler, we require a \textit{list membership proof},  \texttt{FnElem f fns}, which statically guarantees that a given item resides in a list.
{\small
\begin{verbatim}
  data FnElem : mkHandlerFn ((reverse G), E) -> 
                HandlerList -> Type where
                
       FnHere : {xs : HandlerList, f : 
                 mkHandlerFn ((reverse G), E)} ->
         FnElem f ((((reverse G), E) ** (f, fStr)) :: xs)
       FnThere : {xs : HandlerList, f : 
                 mkHandlerFn ((reverse G), E)} ->
               FnElem f xs -> FnElem f (x :: xs)
\end{verbatim}
}
\texttt{FnElem} is parameterised over \texttt{G} and \text{E}, the types of the form elements and the effects used by the handler function. \texttt{FnHere} demonstrates that the element is at the head of the current point of the list, whereas \texttt{FnThere} demonstrates that the element is at some point further in the list. %TODO: this should probably be rewritten
We may then use linguistic reflection and a simple automated proof search to automatically generate the proof at compile time, should one exist. The proof may then be used in subsequent computations: in our case, we use it to retrieve the unique identifier for the function. If the automated proof search fails, compilation will fail with a compile error.

Finally, we must serialise the argument types, supported effects, and return type of the handler function, in order to allow the form data to be correctly deserialised and ensure that the correct handler function is executed on the server. 

Although sending details of the handler function to the client may appear to be a security risk, we envisage that the use of symmetric encryption or a cryptographic nonce would alleviate this. Ultimately, we hope to implement a web server with persistent state, which would eliminate the need for serialisation altogether.

Running the form construction EDSL is achieved as an operation of the CGI effect, \texttt{AddForm}, which then outputs the generated HTML to the page. The generated metadata describing the handler function is serialised as a hidden HTML field.

\subsection{Form Handling}
Once the form has been submitted, a web application may handle the submitted data by invoking the \texttt{HandleForm} CGI operation. This will firstly check for the existence of the hidden \texttt{handler} field, which contains the previously serialised metadata about the form handling function, before deserialising the data into a \texttt{MkHandlerFnTy}. 

With this data, we may then look up the function in the list of registered handlers by using the serialised unique handler identifier. In order to apply the handler function to the data submitted in the form, we must firstly prove to the type-checker that the deserialised \texttt{MkHandlerFnTy} is the same as the one retrieved from the list of registered handlers. We do this by making use of the \texttt{decEq} function, which determines whether two types are equal, returning a proof of equality if so, and a proof of inequality if not.

With this proof, we may then use the \texttt{with} construct, inspired by \textit{views} in Agda \cite{mcbride.mckinna:viewfromleft}, to rewrite the arguments on the left hand side. This allows us to construct a function which, given the handler stored in the list of handlers, the data required to construct the function type and the \texttt{MkHandlerFnTy} deserialised from the form, determines whether the two \texttt{MkHandlerFnTy}s are decidably equal. If so, we may rewrite this on the left hand side, and therefore demonstrate that the recorded function may also be used to handle the form data. If not, the computation is abandoned and an error is shown. % I gave it a shot, right? :P
{\small
\begin{verbatim}
checkFunctions : (reg_fn_ty : MkHandlerFnTy) -> 
                 (frm_fn_ty : MkHandlerFnTy) -> 
                 mkHandlerFn reg_fn_ty -> 
                 Maybe (mkHandlerFn frm_fn_ty)
checkFunctions reg_ty frm_ty reg_fn with 
                             (decEq reg_ty frm_ty)
  checkFunctions frm_ty frm_ty reg_fn | Yes refl = Just reg_fn
  checkFunctions reg_ty frm_ty reg_fn | No _ = Nothing
\end{verbatim}}
We may then parse the arguments according to the types specified by the handler function, and then apply the arguments to the handler function through the use of partial application. Finally, we may run the handler function, ensuring that all updates made to the CGI state are propagated.

%-----------------------------
%-----------------------------

\section{Extended Example: Message Board}
Using these components, we may now consider a larger example of a message board, allowing users to register, log in, view and create threads, and list and create new posts in threads. 

Firstly, we create a database schema in which to record information stored by the message board. We create three tables: \texttt{Users}, which contains a unique User ID, usernames and passwords; \texttt{Threads}, which contains a unique thread ID, a title, and the ID of the user who created the thread; and \texttt{Posts}, which contains a unique post ID, the ID of the thread to which each post belongs, the content of the post, and the ID of the user that created the post.

Secondly, we use a GET variable, \texttt{action}, to indicate which page of the message board should be displayed, and pattern-match on these to call the appropriate function which displays the page. Some pages, such as the page which shows all of the posts in a thread, require a second argument, \texttt{thread\_id}. 
\subsection{Handling requests}
Once the program is invoked via a CGI request, the \texttt{main} function will be called. We then run the remainder of the program through a call to \texttt{runCGI}, which we initialise with empty initial environments for the CGI, Session and SQLite effects, so they may be used in further computations. 

{\small
\begin{verbatim}
main : IO ()
main = do (runCGI [initCGIState, 
                  InvalidSession, ()] 
           handleRequest)
          pure ()
\end{verbatim}
}
The \texttt{handleRequest} function firstly checks to see whether the CGI request must handle previously-submitted form data, via the \texttt{isHandlerSet} function. If so, then the form handling routine is called, which parses the POST data in order to call the correct form handling function. If not, then the \texttt{handleNonFormRequest} function is called, which inspects the GET variables in order to display the correct page.
{\small
\begin{verbatim}
handleRequest : CGIProg [SESSION 
  (SessionRes SessionUninitialised), 
  SQLITE ()] ()
handleRequest = do 
  handler_set <- isHandlerSet
  if handler_set then do
    lift' (handleForm handlers)
    Effects.pure ()
  else do
    action <- lift' (queryGetVar "action")
    thread_id <- lift' (queryGetVar "thread_id")
    handleNonFormRequest action (map strToInt thread_id)
\end{verbatim}
}
\subsection{Thread Creation}
We specify four forms: one to handle registration, one to handle logging in, one to handle the creation of new threads, and one to handle the creation of new posts. One such example would be the form used to create a new thread, which contains elements for the title of the new thread and the content of the first post of the new thread.

{\small
\begin{verbatim}
newThreadForm : UserForm
newThreadForm = do
  addTextBox "Title" FormString Nothing
  addTextBox "Post Content" FormString Nothing 
  useEffects [CgiEffect, SessionEffect, SqliteEffect]
  addSubmit handleNewThread handlers
\end{verbatim}
}
The form consists of two text boxes: one for the title of the thread, and one for the content of the first post. Both are of type \texttt{String}, as denoted by the \texttt{FormString} argument, and both have no default value. The handler function may make use of the \texttt{CGI}, \texttt{SESSION} and \texttt{SQLITE} effects, and the handler function is specified as \texttt{handleNewThread}. The \texttt{handlers} argument refers to the list of form handlers, and takes the following form:
{\small
\begin{verbatim}
handlers : HandlerList
handlers = [(([FormString, FormString], 
              [CgiEffect, SessionEffect, SqliteEffect]) ** 
               (handleRegisterForm, "handleRegisterForm")),
               
            (([FormString, FormString], 
              [CgiEffect, SessionEffect, SqliteEffect]) ** 
               (handleNewThread, "handleNewThread")),
             ...
            ]
\end{verbatim}
}
Creating a new thread requires a user to be logged in, so that the thread starter may be recorded in the database. In order to do this, we make use of the session handler. We define a function \texttt{withSession}, which attempts to retrieve the session associated with the current request, and if it exists, executes a function which is passed the associated session data. If not, then a failure function is called instead. Should the form handler function be called with invalid arguments, an error is shown.
{\small
\begin{verbatim}
handleNewThread : Maybe String -> 
                  Maybe String -> 
                  FormHandler [CGI (InitialisedCGI 
                                 TaskRunning), 
                               SESSION (SessionRes 
                                 SessionUninitialised), 
                               SQLITE ()]  
handleNewThread (Just title) (Just content) = do 
  withSession (addNewThread title content) notLoggedIn
  pure ()
handleNewThread _ _ = do 
  outputWithPreamble "<h1>Error</h1><br />There was 
       an error posting your thread."
  pure ()
\end{verbatim}
}
Once we have loaded the session data from the database, we then check whether the \texttt{UserID} variable is set, which demonstrates that a user has successfully logged into the system, and allows us to use the ID in subsequent computations. The database operation to insert the thread into the database is performed by the \texttt{threadInsert} function, which makes use of the \texttt{executeInsert} library function. This function abstracts over the low-level resource usage protocol, enabling for provably-correct database access without the excess boilerplate code. In addition, the function also returns the unique row ID of the last item which was inserted, which may be used in subsequent computations. In the case of the message board, we use this to associate the first post of the thread with the thread being inserted.
{\small
\begin{verbatim}
threadInsert : Int -> 
               String -> 
               String -> 
               Eff IO [SQLITE ()] Bool
threadInsert uid title content = do
  let query = "INSERT INTO `Threads` 
    (`UserID`, `Title`) VALUES (?, ?)"
  insert_res <- (executeInsert DB_NAME query 
    [(1, DBInt uid), (2, DBText title)]
  case insert_res of
    Left err => pure False
    Right thread_id => postInsert uid thread_id content
\end{verbatim}
}
\subsection{Listing Threads}
Listing the threads in the database is achieved through the use of the \texttt{executeSelect} library function, which in turn returns either a \texttt{ResultSet} or an error. 
{\small
\begin{verbatim}
getThreads : Eff IO [SQLITE ()] (Either String ResultSet)
getThreads = executeSelect DB_NAME query [] collectThreadResults
  where query = "SELECT `ThreadID`, `Title`, `UserID`, 
    `Username` FROM `Threads` NATURAL JOIN `Users`"
\end{verbatim}
}
Once the result set has been retrieved, we may iterate through the results and output them to the page, including a link to a page which shows the posts associated with the thread. Since we know the structure of the returned row from designing the query, we may pattern match on each returned row to make use of the returned values.
{\small
\begin{verbatim}
traverseThreads : ResultSet -> 
  Eff IO [CGI (InitialisedCGI TaskRunning)] ()
traverseThreads [] = pure ()
traverseThreads (x::xs) = do traverseRow x
                             traverseThreads xs
  where traverseRow : List DBVal -> 
           Eff IO [CGI (InitialisedCGI TaskRunning)] ()
        traverseRow ((DBInt thread_id)::
                     (DBText title)::
                     (DBInt user_id)::
                     (DBText username)::[]) =
           (output \$ "<tr><td>
            <a href=\"?action=showthread&thread_id=" ++ 
            (show thread_id) ++ "\">" ++ 
            title ++ "</a></td><td>" ++ 
            username ++ "</td></tr>") 
        traverseRow _ = pure ()
\end{verbatim}
}
\subsection{Authentication}
Once a user submits the login form, the associated handler queries the database to ascertain whether a user with the given username and password exists through a call to the \texttt{authUser} function. If so, then the session handler is invoked, and a session is initialised with the user ID retrieved from the database. The session ID is then set as a cookie using the CGI effect, so that it may be used in subsequent requests. Any failures, for example with creating a new session or querying the database, are reported to the user.
{\small
\begin{verbatim}
handleLoginForm (Just name) (Just pwd) = do
  auth_res <- lift' (authUser name pwd)
  case auth_res of
    Right (Just uid) => do
      set_sess_res <- setSession uid
      if set_sess_res then do
        lift' (output \$ "Welcome, " ++ name)
        pure ()
      else do
        lift' (output "Could not set session")
        pure ()
    Right Nothing => do
      lift' (output "Invalid username or password")
      pure ()
    Left err => do
      lift' (output \$ "Error: " ++ err)
      pure ()
\end{verbatim}}
Implementations for the insertion and display of posts, alongside registration, are similar in form to those described above, and are as such omitted from this paper.

Although we have described a relatively simple application, we have shown that through the use of embedded domain-specific languages, we may write verified code that fails to compile should resources be incorrectly accessed. Additionally, we have used the form handling mechanism to simply handle the arguments passed by the user. Importantly, we have shown that dependent types can be used to increase confidence in an (albeit simplified) real-world application, without requiring developers to supply proofs or indeed work explicitly with dependent types. 
%-----------------------------
%-----------------------------

\section{Related Work}

%-----------------------------
%-----------------------------

\section{Conclusions}
Dependently-typed languages have, for a long time, remained relatively unused outside of academia. Advances in embedded domain-specific languages have allowed many of the advantages of such languages, including the additional guarantees given by the successful compilation of a program (assuming the use of specific enough tyeps) to be adopted without the additional proofs traditionally required by users of such languages.

We believe we have demonstrated that embedded domain-specific languages can be used to make use of the power of dependently-typed languages without incurring the traditional overheads of 
\subsection{Further Work}
We have shown that embedded domain-specific languages using dependent types and algebraic effects can be used to increase confidence in web applications by providing additional static guarantees about runtime behaviour, but much more can be done using the same approach.

There are firstly many other applications which make use of specific resource usage protocols, for example popular libraries such as \textit{libgcrypt} \cite{libgcrypt}. Applying a similar approach would allow for sensitive programs requiring cryptographic routines to be written using a language with full dependent types, in turn adding an extra layer of confidence to their security. 

Whilst the use of CGI allows for experimenting with the use of dependent types in a real-world scenario such as web programming, there remain practical considerations about its scalability, as a separate process must be created for each individual request request. Ultimately, we would like to create a web server written in \idris{}, which would make more efficient usage of resources. 

Dependently-typed languages provide great promise for the construction of secure and correct programs. Through the use of embedded domain-specific languages, we hope that
% Cryptography bindings would be really good.
% Integration with a web server instead of doing everything over CGI
% Improvements to form handling system
% Less raw SQL, use get more type-safety by using more complex EDSLs for database access thus further minimising errors


%\appendix
%\section{Appendix Title}

%This is the text of the appendix, if you need one.

%-----------------------------
%-----------------------------

\acks
% SICSA / EPSRC (grant number?
% #idris
% Idris contributors, in particular Melissa for the SQLite bindings and whoever wrote Network.Cgi

% We recommend abbrvnat bibliography style.
% #firstworldanarchists
\bibliographystyle{plainnat}

% The bibliography should be embedded for final submission.

\bibliography{refs}
%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

